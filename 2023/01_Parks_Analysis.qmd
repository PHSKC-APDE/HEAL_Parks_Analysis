---
title: "HEAL Parks 2023 Analysis"
author: "Ronald Buie"
date-modified: "`r Sys.Date()`"

format: 
  pdf:
    toc: true
    number-sections: true
---

# Front Matter


## ITHS REDCap

Data are currently stored in ITHS REDCap. This is currently managed by the program managers and Ronald. This script will pull from the project if correct information is provided (see **secrets and tokens** in the **Setting Environment** section below.)

## This is a Quarto Document

Quarto enables you to weave together documentation and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.


# 1 Setting Up Environment

```{r define constant and environment variables}
USEGOODDATA <- TRUE
```

```{r load required packages}
# we prefer to use pacman to manage cran packages. 
# First check if pacman is installed. If not, install it.
if(!"pacman" %in% installed.packages()) {
  install.packages("pacman")
}

# load and install packages using pacman. 
# Pacman will install and load missing packages.
pacman::p_load("here") #used to simplify calls to local directory

```

## Secrets and tokens

In order to pull data directly from REDCap, API information must be provided. You should create a file called "secrets.txt" in this directory. This file should contain the following information:

Note, that the .gitignore for this project is configured to exclude your secrets.txt file, so, by default, it will not upload to github, and you will not be able to see other users' secrets.txt. They are only stored on your machine.


# 2 Load Data

```{r import data}
library(RCurl)
library(jsonlite)
library(here)
library(data.table)
if (file.exists(here("2023/secrets.txt"))) {
  source(here("2023/secrets.txt"))
} else {
  warning("secrets not found. checking for data.csv")
  if(!file.exists(here("2023/data.csv"))){
    stop("data not found")
  }
}


#!/usr/bin/env Rscript
token <- "FBB8FA4EA7136C81F88BEA9D15254338"
url <- "https://redcap.iths.org/api/"

formData <- list("token"=token,
    content='record',
    action='export',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)
response <- httr::POST(url, body = formData, encode = "form")
result <- httr::content(response)
#print(result)
```

```{r convert object and set data types}
result <- postForm(
    api_url,
    token=api_token,
    content='record',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)

RawSOPARCObservations <- as.data.table(fromJSON(result), )

#RawSOPARCObservations <- data.table(fromJSON(result), keep.rownames = FALSE, stringsAsFactors = FALSE)


#convert countables to numeric
RawSOPARCObservations$tar_area <- as.numeric(RawSOPARCObservations$tar_area)
RawSOPARCObservations$num_child_prim <- as.numeric(RawSOPARCObservations$num_child_prim)
RawSOPARCObservations$num_child_snd <- as.numeric(RawSOPARCObservations$num_child_snd)
RawSOPARCObservations$num_child_spec <- as.numeric(RawSOPARCObservations$num_child_spec)
RawSOPARCObservations$num_teen_prim <- as.numeric(RawSOPARCObservations$num_teen_prim)
RawSOPARCObservations$num_teen_snd <- as.numeric(RawSOPARCObservations$num_teen_snd)
RawSOPARCObservations$num_teen_spec <- as.numeric(RawSOPARCObservations$num_teen_spec)
RawSOPARCObservations$num_adult_prim <- as.numeric(RawSOPARCObservations$num_adult_prim)
RawSOPARCObservations$num_adult_snd <- as.numeric(RawSOPARCObservations$num_adult_snd)
RawSOPARCObservations$num_adult_spec <- as.numeric(RawSOPARCObservations$num_adult_spec)
RawSOPARCObservations$num_senior_prim <- as.numeric(RawSOPARCObservations$num_senior_prim)
RawSOPARCObservations$num_senior_snd <- as.numeric(RawSOPARCObservations$num_senior_snd)
RawSOPARCObservations$num_senior_spec <- as.numeric(RawSOPARCObservations$num_senior_spec)

#NOT NEEDED #properly type all text fields and turn "" to NA
# chcols = names(RawSOPARCObservations)[sapply(RawSOPARCObservations, is.character)]
# RawSOPARCObservations[, (chcols) := lapply(.SD, type.convert, as.is=TRUE), .SDcols=chcols]


#convert time to time data type and save as separate variables
RawSOPARCObservations[, timestampPOSIX := as.POSIXct(strptime(start_time, "%Y-%m-%d %H:%M"), "America/Los_Angeles") ] #a POSIX format of time
RawSOPARCObservations[, datePOSIX := as.Date(RawSOPARCObservations$timestampPOSIX, tz = "America/Los_Angeles")] #a data.table integer format of second of the day
#RawSOPARCObservations[, idate := IDateTime(timestampPOSIX)$idate] #a data.table integer format of second of the day
#add day of the week
RawSOPARCObservations[, day := weekdays(timestampPOSIX)]
#add weekend indicator
RawSOPARCObservations[, weekend := ifelse(day %in% c("Saturday", "Sunday"), 1, 0)]

#some saved work
                #accessible_check <- SOPARCObservations$accessible
                # usable_check <- SOPARCObservations$usable
                # lit_check <- SOPARCObservations$lit
                # occupied_check <- SOPARCObservations$occupied
                # supervised_check <- SOPARCObservations$supervised
                # organized_check <- SOPARCObservations$organized
                # equipped_check <- SOPARCObservations$equipped
                # num_child_prim_check <- SOPARCObservations$num_child_prim
                # num_child_snd_check <- SOPARCObservations$num_child_snd
                # num_child_spec_check <- SOPARCObservations$num_child_spec
                # num_teen_prim_check <- SOPARCObservations$num_teen_prim
                # num_teen_snd_check <- SOPARCObservations$num_teen_snd
                # num_teen_spec_check <- SOPARCObservations$num_teen_spec
                # num_adult_prim_check <- SOPARCObservations$num_adult_prim
                # num_adult_snd_check <- SOPARCObservations$num_adult_snd
                # num_adult_spec_check <- SOPARCObservations$num_adult_spec
                # num_senior_prim_check <- SOPARCObservations$num_senior_prim
                # num_senior_snd_check <- SOPARCObservations$num_senior_snd
                # num_senior_spec_check <- SOPARCObservations$num_senior_spec
                # prim_act_name_check <- SOPARCObservations$prim_act_name
                # prim_act_other_check <- SOPARCObservations$prim_act_other
                # yesno_snd_check <- SOPARCObservations$yesno_snd
                # snd_act_name_check <- SOPARCObservations$snd_act_name
                # other_act_snd_check <- SOPARCObservations$other_act_snd
                # yesno_spec_check <- SOPARCObservations$yesno_spec
                # spec_act_name_check <- SOPARCObservations$spec_act_name
                # other_act_spec_check <- SOPARCObservations$other_act_spec
                # comments_check <- SOPARCObservations$comments
                # 
```

```{r identify and drop incorrect observations}

SOPARCObservations <- copy(RawSOPARCObservations)

#remove duplicates
SOPARCObservations <- SOPARCObservations[!duplicated(SOPARCObservations[, setdiff(names(SOPARCObservations), "record_id"), with = FALSE]),]

####TESTING####
#remove data with incomplete entry status
SOPARCObservations <- SOPARCObservations[park_scan_data_collection_complete %in% "Complete",]
###############

#drop observations without a time, we cannot use these
SOPARCObservations <- SOPARCObservations[start_time != "",]
#drop observations with missing park names, we cannot use these
SOPARCObservations <- SOPARCObservations[!(park_name %in% ""),]

#redact inaccurate subarea labels
SOPARCObservations[park_name %in% c("Hazelnut Park", 
                                    "Puget Sound Park",
                                    "Tukwila Community Center",
                                    "Tukwila Park",
                                    "Fort Dent Park - South",
                                    "Fort Dent Park - North") & sub_area == "0", sub_area := ""]

#remove pre-study observation (test data)
SOPARCObservations <- SOPARCObservations[record_id >= 141,]
SOPARCObservations <- SOPARCObservations[datePOSIX >= "2023-07-01",]

setorder(SOPARCObservations, cols = "timestampPOSIX")



```

For this analysis, we are not using sub areas. These can be collapsed into single areas.
For each observation, sub areas will be collapsed using the following rules:
    numerical observations will be added together
    categorical become affirmative/existing if any of the subareas are affirmative/existing
    timestamp of the earliest observation in the set will be used

Sub areas of the same target area will be assumed to be of the same observation period based on the following logic:
    for a sequence of sub areas observed in the same 50 hours period
    apparantly missing sub-areas will be ignored (assumption: not all sub areas are necessary)

If non unique sub area labels are identified:
    check if the expected list of sub areas are in teh data set
    if too many, attempt to identify redundancies and remove these
    if too few, interpolate missing information



```{r collapse sub areas into a single area}
SOPARCObservationsSubAreas <- copy(SOPARCObservations[sub_area != "",])

remove(SOPARCCollapsedSubAreas) #if this DT exist, remove it because we will recreate it in this chunk

listToCollapse <- SOPARCObservationsSubAreas[ ,  .(sub_area = unique(sub_area)) , by = c("park_name", "tar_area")]
listToCollapseStarts <- SOPARCObservationsSubAreas[, .(first_sub_area = first(sub_area)), by = c("park_name", "tar_area")]



for(index in 1:nrow(listToCollapseStarts)) {
  park <- listToCollapseStarts[index,]$park_name
  target_area <- listToCollapseStarts[index,]$tar_area
  first_sub_area_here <- listToCollapseStarts[index,]$first_sub_area
  SubAreaStarts <- SOPARCObservationsSubAreas[park_name == park & tar_area == target_area & sub_area == first_sub_area_here,]
  #first_sub_area_list <- SOPARCObservationsSubAreas[park_name == park & tar_area == target_area & sub_area == ]
  for(collapseIndex in 1:nrow(SubAreaStarts)) {
    date <- SubAreaStarts[collapseIndex, datePOSIX]
    starttime <- SubAreaStarts[collapseIndex, timestampPOSIX]
    
    endtime <- SubAreaStarts[collapseIndex+1,timestampPOSIX-1]
    if(is.na(endtime)) { endtime <- starttime + 450}
    maxExpectedObservations <- length(unique(SOPARCObservationsSubAreas[park_name == park & tar_area == target_area & datePOSIX == date & (timestampPOSIX >= starttime & timestampPOSIX < endtime ), sub_area]))
    if(nrow(SOPARCObservationsSubAreas[park_name == park & tar_area == target_area & datePOSIX == date & (timestampPOSIX >= starttime & timestampPOSIX < endtime ), ]) <= maxExpectedObservations ){
    TempCollapseResult <- SOPARCObservationsSubAreas[park_name == park & tar_area == target_area & datePOSIX == date & (timestampPOSIX >= starttime & timestampPOSIX < endtime ), .(record_id = first(record_id), 
                                                                                                                                                    redcap_survey_identifier = first(redcap_survey_identifier),
                                                                                                                                                    park_scan_data_collection_timestamp = first(park_scan_data_collection_timestamp),
                                                                                                                                                    obs_initial = first(obs_initial),
                                                                                                                                                    start_time = first(start_time),
                                                                                                                                                    park_name = first(park_name),
                                                                                                                                                    tar_area = first(tar_area),
                                                                                                                                                    sub_area = "X",
                                                                                                                                                    accessible = ifelse(any(accessible %in% "Yes"), "Yes", "No"),
                                                                                                                                                    usable = ifelse(any(usable %in% "Yes"), "Yes", "No"),
                                                                                                                                                    lit = ifelse(any(lit %in% "Yes"), "Yes", "No"),
                                                                                                                                                    occupied = ifelse(any(occupied %in% "Yes"), "Yes", "No"),
                                                                                                                                                    supervised = ifelse(any(supervised %in% "Yes"), "Yes", "No"),
                                                                                                                                                    organized = ifelse(any(organized %in% "Yes"), "Yes", "No"),
                                                                                                                                                    equipped = ifelse(any(equipped %in% "Yes"), "Yes", "No"),
                                                                                                                                                    num_child_prim = sum(num_child_prim, na.rm = TRUE),
                                                                                                                                                    num_child_snd = sum(num_child_snd, na.rm = TRUE),
                                                                                                                                                    num_child_spec = sum(num_child_spec, na.rm = TRUE),
                                                                                                                                                    num_teen_prim = sum(num_teen_prim, na.rm = TRUE),
                                                                                                                                                    num_teen_snd = sum(num_teen_snd, na.rm = TRUE),
                                                                                                                                                    num_teen_spec = sum(num_teen_spec, na.rm = TRUE),
                                                                                                                                                    num_adult_prim = sum(num_adult_prim, na.rm = TRUE),
                                                                                                                                                    num_adult_snd = sum(num_adult_snd, na.rm = TRUE),
                                                                                                                                                    num_adult_spec = sum(num_adult_spec, na.rm = TRUE),
                                                                                                                                                    num_senior_prim = sum(num_senior_prim, na.rm = TRUE),
                                                                                                                                                    num_senior_snd = sum(num_senior_snd, na.rm = TRUE),
                                                                                                                                                    num_senior_spec = sum(num_senior_spec, na.rm = TRUE),
                                                                                                                                                    prim_act_name = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(prim_act_name), collapse =  ";"), perl = TRUE),
                                                                                                                                                    prim_act_other = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(prim_act_other), collapse =  ";"), perl = TRUE),
                                                                                                                                                    yesno_snd = ifelse(any(yesno_snd %in% "Yes"), "Yes", "No"),
                                                                                                                                                    snd_act_name = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(snd_act_name), collapse =  ";"), perl = TRUE),
                                                                                                                                                    other_act_snd = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(other_act_snd), collapse =  ";"), perl = TRUE),
                                                                                                                                                    yesno_spec = ifelse(any(yesno_spec %in% "Yes"), "Yes", "No"),
                                                                                                                                                    spec_act_name = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(spec_act_name), collapse =  ";"), perl = TRUE),
                                                                                                                                                    other_act_spec = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(other_act_spec), collapse =  ";"), perl = TRUE),
                                                                                                                                                    comments = gsub("^(\\;)*|(?<=(\\;))(\\;)|(\\;)*$","",paste(unique(comments), collapse =  ";"), perl = TRUE),
                                                                                                                                                    park_scan_data_collection_complete = last(park_scan_data_collection_complete),
                                                                                                                                                    timestampPOSIX = first(timestampPOSIX),
                                                                                                                                                    datePOSIX = first(datePOSIX),
                                                                                                                                                    day = first(day),
                                                                                                                                                    weekend = first(weekend)), ]
    if(nrow(TempCollapseResult) > 1 ) {
      stop(paste("Failed to compress observations, check result of", park, target_area, date, "between", starttime, "and", endtime))
    } else if(!exists("SOPARCCollapsedSubAreas")) {
      SOPARCCollapsedSubAreas <- TempCollapseResult
    } else {
      SOPARCCollapsedSubAreas <-  rbind(SOPARCCollapsedSubAreas, TempCollapseResult)
    }
    
    } else {
      stop("there are too many sub areas in scope. Need to resolve for proper assignment")
    }
  }
}


#combine observations without sub areas, and our newly collapsed sub areas, into a single DT
SOPARCObservations <- rbind(SOPARCObservations[sub_area == "",], SOPARCCollapsedSubAreas)

```


```{r check if expected number of observations exist per park}




```

```{r correcting errors in data}

referenceDT <- SOPARCObservations[, .(areaCount = max(as.numeric(tar_area))), by = park_name]
observationsPerPark <- SOPARCObservations[, .(observationCount = .N), by = park_name]
parkStats <- merge(referenceDT, observationsPerPark)
parkStats[, expectedObservationCount := areaCount*24]
parkStats[, meetsExpected := ifelse(expectedObservationCount == observationCount, "PASS", "FAIL")]

SOPARCObservationsOK <- SOPARCObservations[park_name %in% parkStats[meetsExpected %in% "PASS", park_name],]
SOPARCObservationsToFix <- SOPARCObservations[park_name %in% parkStats[meetsExpected %in% "FAIL", park_name],]

#start first pass


#for each day of observation with too many observations per day, try to resolve to 24xtarget area
parkStats$strateg1exec <- TRUE
parkStats$numberDaysOver <- 0
parkStats$numberDaysUnder <- 0
parkStats$numberDaysObserved <- 3
parkStats$numberDaysComplete <- 3


#testing sets
park <- "Arbor Lake"


for(park in parkStats[meetsExpected == "FAIL",]$park_name) {
  SOPARCSingle <- SOPARCObservations[park_name == park,]
  areasExpected <- parkStats[park_name == park,areaCount]
  observationsExpected <- parkStats[park_name == park,areaCount] * 8
  days <- unique(SOPARCSingle[,datePOSIX])
  #if only 3 days have 24*numberofarea +/- x observations, drop the other days and execute strategy 1 on remaining 3 days
  x <- 5
  stratResult <- SOPARCSingle[, .("N" = .N,"exact" = .N == observationsExpected ,"inRange" = (.N >= observationsExpected - x) & (.N <= observationsExpected +x), "under" = (.N < observationsExpected), "over" = (.N > observationsExpected)),by = datePOSIX]
  parkStats[park_name == park,]$numberDaysComplete <- sum(stratResult$exact)
  parkStats[park_name == park,]$numberDaysOver <- sum(stratResult$over)
  parkStats[park_name == park,]$numberDaysUnder <-sum(stratResult$under)
  parkStats[park_name == park,]$numberDaysObserved <- nrow(stratResult)
  if(parkStats[park_name == park,]$numberDaysObserved == 3 & parkStats[park_name == park,]$numberDaysComplete == 2) { #what to do if there are the correct number of days and only one day is not exact
    dateToFix <- stratResult[exact == "FALSE",]$datePOSIX
    if(all(SOPARCSingle[ datePOSIX == dateToFix, .N <= 8 , by = tar_area]$V1)) { #if no target area has more than the expected, insert missing observations into the day
      SOPARCSingleToFix <- SOPARCSingle[ datePOSIX == dateToFix, ]
      periodTracker <- 1
      #expectedTargetArea <- 1
      rowCounter <- 1
      nextExpectedTargetArea <- ifelse(areasExpected == 1, 1, 2)
      periodStartTimes <- c(0730, #start morning1
                       0800, #start morning2
                       1230, #start L1
                       1300, #start L2
                       1530, #start A1
                       1600, #start A2
                       1830, #start E1
                       1900) #start E2
      for(expectedTargetArea in 1:areasExpected) {
        if(nrow(SOPARCSingleToFix[tar_area == expectedTargetArea,]) != 8){
          numberToInsert <- 8 - nrow(SOPARCSingleToFix[tar_area == expectedTargetArea,])
          createEmptyObservation <- function(park, period, expectedTargetArea, areasExpected) {
                                  periodStartTimes <- c(0730, #start morning1
                       0800, #start morning2
                       1230, #start L1
                       1300, #start L2
                       1530, #start A1
                       1600, #start A2
                       1830, #start E1
                       1900) #start E2
                       timeToInterpolate <- round(periodStartTimes[periodTracker] + (30 * (expectedTargetArea/areasExpected))-(30 * (1/areasExpected)),0) #calculate how far into the observation period thetime should be set
          timeToInterpolateChar <- ifelse(nchar(as.character(timeToInterpolate)) == 3, paste0("0",substr(as.character(timeToInterpolate),1,1),":",substr(as.character(timeToInterpolate),2,3)), paste0(substr(as.character(timeToInterpolate),1,2),":",substr(as.character(timeToInterpolate),3,4)))
          timestampToInterpolate <- paste(as.character(dateToFix),timeToInterpolateChar)
                tempObs <- data.table(record_id = "X",
                                   redcap_survey_identifier = "",
                                   park_scan_data_collection_timestamp = "",
                                   obs_initial = "APDE",
                                   start_time = timestampToInterpolate,
                                   park_name = park,
                                   tar_area = expectedTargetArea,
                                   sub_area = "",
                                   accessible = "",
                                   usable = "",
                                   lit = "",
                                   occupied = "",
                                   supervised = "",
                                   organized = "",
                                   equipped = "",
                                   num_child_prim = NA,
                                   num_child_snd = NA,
                                   num_child_spec = NA,
                                   num_teen_prim = NA,
                                   num_teen_snd = NA,
                                   num_teen_spec = NA,
                                   num_adult_prim = NA,
                                   num_adult_snd = NA,
                                   num_adult_spec = NA,
                                   num_senior_prim = NA,
                                   num_senior_snd = NA,
                                   num_senior_spec = NA,
                                   prim_act_name = "",
                                   prim_act_other = "",
                                   yesno_snd = "",
                                   snd_act_name = "",
                                   other_act_snd = "",
                                   yesno_spec = "",
                                   spec_act_name = "",
                                   other_act_spec = "",
                                   comments = "",
                                   park_scan_data_collection_complete = "",
                                   timestampPOSIX = as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles"),
                                   datePOSIX = as.Date(as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles"), tz = "America/Los_Angeles"),
                                   day = weekdays(as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles")),
                                   weekend = ifelse(weekdays(as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles")) %in% c("Saturday", "Sunday"), 1, 0))
                return(tempObs)
          }
          while(numberToInsert != 0){ # attempt to insert into the most underweighted time of day note, we don't need to worry about 1st or second period of that time (l1 vs l2)
            if(nrow(SOPARCSingleToFix[tar_area == expectedTargetArea & hour(timestampPOSIX) < 15,]) <= nrow(SOPARCSingleToFix[tar_area == expectedTargetArea & hour(timestampPOSIX) >= 15,])) { #first or second half of day
              if(nrow(SOPARCSingleToFix[tar_area == expectedTargetArea & hour(timestampPOSIX) < 15,][hour(timestampPOSIX) < 12,]) <= nrow(SOPARCSingleToFix[tar_area == expectedTargetArea & hour(timestampPOSIX) < 15,][hour(timestampPOSIX) >= 12,])) { #first or second of first half
                #insert intro morning
                periodTracker <- 1
                SOPARCObservationsToFix <-  rbind(createEmptyObservation(park, periodTracker, expectedTargetArea, areasExpected),SOPARCObservationsToFix)
                numberToInsert <- numberToInsert -1
              } else {
                #insert into lunch
                periodTracker <- 3
                SOPARCObservationsToFix <-  rbind(createEmptyObservation(park, periodTracker, expectedTargetArea, areasExpected),SOPARCObservationsToFix)

                numberToInsert <- numberToInsert -1
              }
            } else {
              if(nrow(SOPARCSingleToFix[tar_area == expectedTargetArea & hour(timestampPOSIX) >= 15,][hour(timestampPOSIX) < 18,]) <= nrow(SOPARCSingleToFix[tar_area == expectedTargetArea & hour(timestampPOSIX) >= 15,][hour(timestampPOSIX) >= 18,])) { #first or second of second half)
                #insert into afternoon
                periodTracker <- 5
                SOPARCObservationsToFix <-  rbind(createEmptyObservation(park, periodTracker, expectedTargetArea, areasExpected),SOPARCObservationsToFix)

                numberToInsert <- numberToInsert -1
              }else {
                #insert into evening
                periodTracker <- 7
                SOPARCObservationsToFix <-  rbind(createEmptyObservation(park, periodTracker, expectedTargetArea, areasExpected),SOPARCObservationsToFix)

                numberToInsert <- numberToInsert -1
              }
            }
            

          }
          
        }
      }
      # for(expectedTargetArea in 1:areasExpected) {
      #   
      #   expectedTargetArea <- (((observationCounter-1)%%areasExpected)+1)
      # 
      #   # periodEndTimes <- c(0759, #end morning1
      #   #                      0829, #end morning2
      #   #                      1300, #end L1
      #   #                      1329, #end L2
      #   #                      1559, #end A1
      #   #                      1629, #end A2
      #   #                      1859, #end E1
      #   #                      1929) #end E2
      #   
      #   if(SOPARCSingleToFix[(rowCounter), ]$tar_area != expectedTargetArea) {
      #     timeToInterpolate <- round(periodStartTimes[periodTracker] + (30 * (expectedTargetArea/areasExpected))-(30 * (1/areasExpected)),0) #calculate how far into the observation period thetime should be set
      #     timeToInterpolateChar <- ifelse(nchar(as.character(timeToInterpolate)) == 3, paste0("0",substr(as.character(timeToInterpolate),1,1),":",substr(as.character(timeToInterpolate),2,3)), paste0(substr(as.character(timeToInterpolate),1,2),":",substr(as.character(timeToInterpolate),3,4)))
      #     timestampToInterpolate <- paste(as.character(dateToFix),timeToInterpolateChar)
      #     TempResult <- data.table(record_id = "X",
      #                              redcap_survey_identifier = "",
      #                              park_scan_data_collection_timestamp = "",
      #                              obs_initial = "APDE",
      #                              start_time = timestampToInterpolate,
      #                              park_name = park,
      #                              tar_area = expectedTargetArea,
      #                              sub_area = "",
      #                              accessible = "",
      #                              usable = "",
      #                              lit = "",
      #                              occupied = "",
      #                              supervised = "",
      #                              organized = "",
      #                              equipped = "",
      #                              num_child_prim = NA,
      #                              num_child_snd = NA,
      #                              num_child_spec = NA,
      #                              num_teen_prim = NA,
      #                              num_teen_snd = NA,
      #                              num_teen_spec = NA,
      #                              num_adult_prim = NA,
      #                              num_adult_snd = NA,
      #                              num_adult_spec = NA,
      #                              num_senior_prim = NA,
      #                              num_senior_snd = NA,
      #                              num_senior_spec = NA,
      #                              prim_act_name = "",
      #                              prim_act_other = "",
      #                              yesno_snd = "",
      #                              snd_act_name = "",
      #                              other_act_snd = "",
      #                              yesno_spec = "",
      #                              spec_act_name = "",
      #                              other_act_spec = "",
      #                              comments = "",
      #                              park_scan_data_collection_complete = "",
      #                              timestampPOSIX = as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles"),
      #                              datePOSIX = as.Date(as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles"), tz = "America/Los_Angeles"),
      #                              day = weekdays(as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles")),
      #                              weekend = ifelse(weekdays(as.POSIXct(strptime(timestampToInterpolate, "%Y-%m-%d %H:%M"), "America/Los_Angeles")) %in% c("Saturday", "Sunday"), 1, 0))
      #     SOPARCObservationsToFix <- rbind(TempResult, SOPARCObservationsToFix)
      #   } else {
      #     rowCounter <- rowCounter + 1
      #   }
      #   if(expectedTargetArea == areasExpected) {
      #     periodTracker <- periodTracker + 1
      #   } 
      #}
    }
    
    
  } else {
    parkStats[park_name == park,]$strateg1exec <- FALSE

  }
}

referenceDT <- SOPARCObservationsToFix[, .(areaCount = max(as.numeric(tar_area))), by = park_name]
observationsPerPark <- SOPARCObservationsToFix[, .(observationCount = .N), by = park_name]
parkStats <- merge(referenceDT, observationsPerPark)
parkStats[, expectedObservationCount := areaCount*24]
parkStats[, meetsExpected := ifelse(expectedObservationCount == observationCount, "PASS", "FAIL")]

SOPARCObservationsCorrected <- copy(SOPARCObservationsToFix[park_name %in% parkStats[meetsExpected == "PASS", park_name],])
```

```{r}

SOPARCObservationsPost <- rbind(SOPARCObservationsOK, SOPARCObservationsCorrected)

referenceDT <- SOPARCObservationsPost[, .(areaCount = max(as.numeric(tar_area))), by = park_name]
observationsPerPark <- SOPARCObservationsPost[, .(observationCount = .N), by = park_name]
parkStats <- merge(referenceDT, observationsPerPark)
parkStats[, expectedObservationCount := areaCount*24]
parkStats[, meetsExpected := ifelse(expectedObservationCount == observationCount, "PASS", "FAIL")]


```

```{r}
#resolve redundant observations
for(park in unique(SOPARCObservations[,park_name])) {
  for(area in 1:max(SOPARCObservations[park_name == park, tar_area])) {
    #check if the expected number of observations exists for each area
    if(all(SOPARCObservations[park_name == park & tar_area == area, sub_area ] == "")) { #testing areas where all observations are without sub areas
      if(!nrow(SOPARCObservations[park_name == park & tar_area == area,] ) == 24) { #checks that there are exactly 24 observations. Note, this skips any that have 24 to instead assert sequential observation order. That may be an awful assumption
        #check that there are 3 days and 8 observations per day for each target area of the park
        if(length(unique(SOPARCObservations[park_name == park & tar_area == area,]$datePOSIX)) == 3){           #checks for those that have 3 days...

          #confirm that each target area has 8 observations per day, and make corrections if not
          for(day in unique(SOPARCObservations[park_name == park & tar_area == area,]$idate)) {
            if(nrow(SOPARCObservations[park_name == park & tar_area == area & idate == day,]) > 8) {
              numberToFix <- nrow(SOPARCObservations[park_name == park & tar_area == area & idate == day,]) - 8
              #things to do to resolve when there are extra observations in a day
              print(paste("there are", numberToFix, "too many observations in", park, area, as.Date(day)))
              print("attempting to resolve by temporal proximity and data similarity")
              #where X is the number of excess observations, choose X_1 where X_1 is an entry that matches at least one other entry in all regards except timestamp and ID
              #if more than 2 identical items exists within a +/- 30m timespan of X_1, delete X_1
              #X-1, if X >0 repeat
              duplicates <- SOPARCObservations[park_name == park & tar_area == area & as.Date(timestampPOSIX, tz = "America/Los_Angeles") == day,record_id][duplicated(SOPARCObservations[park_name == park & tar_area == area & as.Date(timestampPOSIX, tz = "America/Los_Angeles") == day, !c("record_id","start_time","timestampPOSIX", "itimeOfDay")],by = )]
              duplicateseWithNearMatches <- NA
              
              #check sequentially if there are 3 items within 30 minutes of each other, and one is identical
              for( id in duplicates) {
                varsToMatchOn <- c("park_name",
                                   "tar_area",
                                   "sub_area",
                                   "accessible",
                                   "usable",
                                   "lit",
                                   "occupied",
                                   "supervised",
                                   "organized",
                                   "equipped",
                                   "num_child_prim",
                                   "num_child_snd",
                                   "num_child_spec",
                                   "num_teen_prim",
                                   "num_teen_snd",
                                   "num_teen_spec",
                                   "num_adult_prim",
                                   "num_adult_snd",
                                   "num_adult_spec",
                                   "num_senior_prim",
                                   "num_senior_snd",
                                   "num_senior_spec",
                                   "prim_act_name",
                                   "prim_act_other",
                                   "yesno_snd",
                                   "snd_act_name",
                                   "other_act_snd",
                                   "yesno_spec",
                                   "spec_act_name",
                                   "other_act_spec",
                                   "comments")
                accessible_check <- SOPARCObservations[record_id == id]$accessible
                usable_check <- SOPARCObservations[record_id == id]$usable
                lit_check <- SOPARCObservations[record_id == id]$lit
                occupied_check <- SOPARCObservations[record_id == id]$occupied
                supervised_check <- SOPARCObservations[record_id == id]$supervised
                organized_check <- SOPARCObservations[record_id == id]$organized
                equipped_check <- SOPARCObservations[record_id == id]$equipped
                num_child_prim_check <- SOPARCObservations[record_id == id]$num_child_prim
                num_child_snd_check <- SOPARCObservations[record_id == id]$num_child_snd
                num_child_spec_check <- SOPARCObservations[record_id == id]$num_child_spec
                num_teen_prim_check <- SOPARCObservations[record_id == id]$num_teen_prim
                num_teen_snd_check <- SOPARCObservations[record_id == id]$num_teen_snd
                num_teen_spec_check <- SOPARCObservations[record_id == id]$num_teen_spec
                num_adult_prim_check <- SOPARCObservations[record_id == id]$num_adult_prim
                num_adult_snd_check <- SOPARCObservations[record_id == id]$num_adult_snd
                num_adult_spec_check <- SOPARCObservations[record_id == id]$num_adult_spec
                num_senior_prim_check <- SOPARCObservations[record_id == id]$num_senior_prim
                num_senior_snd_check <- SOPARCObservations[record_id == id]$num_senior_snd
                num_senior_spec_check <- SOPARCObservations[record_id == id]$num_senior_spec
                prim_act_name_check <- SOPARCObservations[record_id == id]$prim_act_name
                prim_act_other_check <- SOPARCObservations[record_id == id]$prim_act_other
                yesno_snd_check <- SOPARCObservations[record_id == id]$yesno_snd
                snd_act_name_check <- SOPARCObservations[record_id == id]$snd_act_name
                other_act_snd_check <- SOPARCObservations[record_id == id]$other_act_snd
                yesno_spec_check <- SOPARCObservations[record_id == id]$yesno_spec
                spec_act_name_check <- SOPARCObservations[record_id == id]$spec_act_name
                other_act_spec_check <- SOPARCObservations[record_id == id]$other_act_spec
                comments_check <- SOPARCObservations[record_id == id]$comments
                
                temporalmid <- SOPARCObservations[record_id == id, itimeOfDay]
                print(paste("searching for records within +/- 30m of record", id))
                print(paste(SOPARCObservations[park_name == park & tar_area == area & idate == day & record_id != id & (itimeOfDay > temporalmid - 1800 & itimeOfDay < temporalmid + 1800),]$record_id, "was found"))
                #duplicated(SOPARCObservations[park_name == park & tar_area == area & idate == day,],by =   varsToMatchOn)

                #SOPARCObservations[park_name == park & tar_area == area & as.Date(timestampPOSIX, tz = "America/Los_Angeles") == day & (itimeOfDay > temporalmid - 1800 & itimeOfDay < temporalmid + 1800),]
                
              }

              SOPARCObservations[park_name == park & tar_area == area,]

              while(numberToFix > 0) {
                
              }
              
              
            }
            if(nrow(SOPARCObservations[park_name == park & tar_area == area & as.Date(timestampPOSIX, tz = "America/Los_Angeles") == day,]) < 8) {
              print(paste("there are too few observations in", park, area, as.Date(day, tz = "America/Los_Angeles")))
            }
          }
          
        } else if(length(unique(as.Date(SOPARCObservations[park_name == park & tar_area == area,]$timestampPOSIX, tz = "America/Los_Angeles"))) > 3){
          print(paste("more than 3 days detected for", park, area))
        } else if((length(unique(as.Date(SOPARCObservations[park_name == park & tar_area == area,]$timestampPOSIX, tz = "America/Los_Angeles"))) < 3)) {
          print(paste("less than 3 days detected for", park, area))
        } else {
          print(paste("undefined date error found in", park, area))
        }
        
      }
    } else { #testing observations where any of the area has sub areas
      #for(subarea in SOPARCObservations[park_name == park & tar_area == area, sub_area ]) {
    }
  }
}
```




```{r temp create park and area reference table with quality checks}


referenceDT <- SOPARCObservations[, .(areaCount = max(as.numeric(tar_area))), by = park_name]
observationsPerPark <- SOPARCObservations[, .(observationCount = .N), by = park_name]
parkStats <- merge(referenceDT, observationsPerPark)
parkStats[, expectedObservationCount := areaCount*24]
parkStats[, meetsExpected := ifelse(expectedObservationCount == observationCount, "PASS", "FAIL")]


```

```{r select analysis set to use}
if(USEGOODDATA) {
  SOPARCAnalysisSet <- copy(SOPARCObservations[park_name %in% parkStats[meetsExpected == "PASS"]$park_name]) #only use parks that have expected number of observation
} else {
  SOPARCAnalysisSet <- copy(SOPARCObservations) #use all parks
}
```



# Parameterizing data

Parks are observed multiple times. 8 times per day. These are in a morning, lunch, afternoon, and evening period (two data collections per period). This process is repeated for 3 days (24 sets of observations per park).

Each park is divided into one or more areas. All areas should be observed during a single observation period. Some areas may be further divided into sub areas. In our data, each area is simply assigned a number.

```{r period assignment based on sequence}


  


expectedTimeBreakpoints <- c(0800, #start morning2
                             0830, #between M2 and L1
                             1230, #start L1
                             1300, #start L2
                             1330, # between L2 and A1
                             1530, #start A1
                             1600, #start A2
                             1630, #between A2 and E1
                             1830, #start E1
                             1900) #start E2


breakPointLabels <- c("morning1",
             "morning2",
             "betweenML",
             "lunch1",
             "lunch2",
             "betweenLA",
             "afternoon1",
             "afternoon2",
             "betweeenAE",
             "evening1",
             "evening2")


 
#for remaining observations, create a list of their times, standardized to POSIX
dataCollectionTimes <- as.POSIXct(strptime(SOPARCAnalysisSet$start_time, "%Y-%m-%d %H:%M"), "America/Los_Angeles") 

breakpointAssignments <- breakPointLabels[findInterval(format(dataCollectionTimes, format = "%H%M"), expectedTimeBreakpoints, left.open = T, all.inside = FALSE, rightmost.closed = FALSE)+1]

#assign observed times to scheduled periods. Use only the house (otherwise would attribute date.)
SOPARCAnalysisSet$periodBasedOnBreakpoint <- breakpointAssignments

```

At this point rudementary timestamps have been assigned based on the expected times of observation.
Now we apply a series of heuristics to correct obvious errors.


```{r adjust timestamp assigments}

```


A second approach to assigning time periods relies on the assumption that timestamps are in order (e.g. the first observation of park A area 1 is always "morning1", the second, "morning2" and so on.)

In turn, with this approach, we assign the sequence of the day such that the first morning1 is day 1, the second is day2, and so on. 

For both of the above approaches, we assume that there are the correct number of observation periods such that 1 can be assigned to each period, and 8 to each day.
```{r assign time periods based on sequence}

sequenceLabels <- c("morning1",
             "morning2",
             "lunch1",
             "lunch2",
             "afternoon1",
             "afternoon2",
             "evening1",
             "evening2")


#apply observation period labels based on the order that a park's target area was observed
SOPARCAnalysisSet[order(park_scan_data_collection_timestamp, tar_area), periodBasedOnSequence := rep_len(sequenceLabels, .N), by = "park_name"]


#apply day sequence labels based on the order of a park's observation period
SOPARCAnalysisSet[order(park_scan_data_collection_timestamp, tar_area, periodBasedOnSequence), dayNumberBasedOnSequence := rep_len(1:3, .N), by = "park_name",]


```





save these data to review timestamp assignments
```{r}
#save for manual inspection
write.csv(SOPARCAnalysisSet, "inspectTimestamps.csv")

```


For each park, there should be 3 days of observation. We will detect this by extracting the date per park and putting observations in order of day "1" "2" "3"
```{r  assign observation day}

# #library(lubridate)
#   for(park in unique(SOPARCObservations$park_name)) {
#     daysOfYear <- yday(SOPARCObservations[park_name %in% park, start_time])
#     dayOfYear <- unique(daysOfYear)
#     if(length(dayOfYear) > 3) { warning("more than three days detected for:", park ,"\n") }
#     if(length(dayOfYear) < 3) { warning("less than three days detected for:", park ,"\n") }
#     for(dayCounter  in 1:length(dayOfYear)) {
#       SOPARCObservations[park_name %in% park & yday(start_time) == dayOfYear[dayCounter], analysisDay := dayCounter]
#     }
#   }
```


```{r prep for analysis QA}

PreQADT <- copy(SOPARCAnalysisSet)

#check if all expected time periods exists and are assigned
for(park in unique(PreQADT$park_name)) {
  multiple <- referenceDT[park_name %in% park,]$areaCount
  #check sequence based times
  for(period in sequenceLabels) {
    if(nrow(PreQADT[park_name %in% park & periodBasedOnSequence %in% period, ]) != multiple*3) { 
      PreQADT[park_name %in% park & periodBasedOnSequence %in% period, PeriodBasedOnSequencePass := 0]
    } else {
      PreQADT[park_name %in% park & periodBasedOnSequence %in% period, PeriodBasedOnSequencePass := 1]
    }
    
  }
  for(daycount in 1:3){
    #we will perform 2 check here
    #1 review if the correct number of observations are assigned to each day
    if(nrow(PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, ]) != multiple*8) { 
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayCountBasedOnSequencePass := 0]
    } else {
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayCountBasedOnSequencePass := 1]
    }
    #2 confirm that the observations assigned to the same day are flagged with the same day of the week
    if(length(unique(PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, day])) != 1) { 
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayAssignmentBasedOnSequencePass := 0]
    } else {
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayAssignmentBasedOnSequencePass := 1]
    }
  }
  
}

# 
# #check if any time periods are in between assigned periods
# liminalTimes <- c("betweenML",
#                   "betweenLA",
#                   "betweeenAE")
# if(nrow(PreQADT[periodBasedOnBreakpoint %in% liminalTimes,]) >0){
#   propMissing <- round(nrow(PreQADT[periodBasedOnBreakpoint %in% liminalTimes,])/nrow(PreQADT) ,2)*100
#   warning(paste0("%", propMissing, " of observations are in liminal periods and need to be corrected for proper analysis,"))
#   warning("trimming data to only include observations with properly assigned observation periods. Do not use these results in final analysis.")
#   PreQADT[, passQABP := ifelse(!(periodBasedOnBreakpoint %in% liminalTimes)]
# } else {
#   message("OK status: All observations have been assigned to a time period")
# }
# 
# #check if parks have all expected observations
# pass <- 1
# for(park in unique(PreQADT$park_name)) {
# 
# }

QAVarList <- c("PeriodBasedOnSequencePass",
               "DayCountBasedOnSequencePass",
               "DayAssignmentBasedOnSequencePass")

QAVarList <- quote(list(PeriodBasedOnSequencePass,
               DayCountBasedOnSequencePass,
               DayAssignmentBasedOnSequencePass))

PostQADT <- copy(PreQADT)
```


save these data to review QA output
```{r}
#save for manual inspection
write.csv(PostQADT, "inspectQA.csv")

```


```{r analysis functions}


```


For all analyses, we do not want to distinguish between the first and second of a period (e.g. morning1 and morning2). This chunk attempts to aggregate these according to the following:


positive indicaters | aggregate to
--------------------|----------------------
accessible          | Yes
usable              | Yes
lit                 | Yes
occupied            | Yes
supervised          | Yes
organized           | Yes
equipped            | Yes

counts of           | are aggregated as
--------------------|-----------------------
num_child_prim      | sum
num_child_snd       | sum
num_child_spec      | sum
num_teen_prim       | sum
num_teen_snd        | sum
num_teen_spec       | sum
num_adult_prim      | sum
num_adult_snd       | sum
num_adult_spec      | sum
num_senior_prim     | sum
num_senior_snd      | sum
num_senior_spec     | sum

open text field of  | aggregate to
--------------------|--------------------------
prim_act_name       | concantinate ";"
prim_act_other      | concantinate ";"
snd_act_name        | concantinate ";"
other_act_snd       | concantinate ";"
spec_act_name       |
other_act_spec      |
comments            |


## sub aeras



```{r period aggregation}

if(USEGOODDATA) {
  #check is all QA checks are 1, if any are not one, do not include that park
  invalidParks <- unique(PostQADT[apply(PostQADT[,eval(QAVarList)], 1, mean) != 1, park_name])
  SOPARCtoAggregate <- copy(PostQADT[!(park_name %in% invalidParks),])
} else {
  SOPARCtoAggregate <- copy(PostQADT)
}

#create single periodname for aggregating first and second of each period using sequence periods
SOPARCtoAggregate[periodBasedOnSequence %in% c("morning1","morning2"), period := "morning"]
SOPARCtoAggregate[periodBasedOnSequence %in% c("lunch1","lunch2"), period := "lunch"]
SOPARCtoAggregate[periodBasedOnSequence %in% c("afternoon1","afternoon2"), period := "afternoon"]
SOPARCtoAggregate[periodBasedOnSequence %in% c("evening1","evening2"), period := "evening"]

SOPARCAggregated <- unique.data.frame(SOPARCtoAggregate[, .(park_name, tar_area, dayNumberBasedOnSequence, period)])
  
SOPARCAggregated$accessible <- SOPARCtoAggregate[, ifelse(any(accessible %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$usable <- SOPARCtoAggregate[, ifelse(any(usable %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$lit <- SOPARCtoAggregate[, ifelse(any(lit %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$occupied <- SOPARCtoAggregate[, ifelse(any(occupied %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$supervised <- SOPARCtoAggregate[, ifelse(any(supervised %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$organized <- SOPARCtoAggregate[, ifelse(any(organized %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$equipped <- SOPARCtoAggregate[, ifelse(any(equipped %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1


SOPARCAggregated$num_child_prim <- SOPARCtoAggregate[, sum(as.numeric(num_child_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_child_snd <- SOPARCtoAggregate[, sum(as.numeric(num_child_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_child_spec <- SOPARCtoAggregate[, sum(as.numeric(num_child_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_teen_prim <- SOPARCtoAggregate[, sum(as.numeric(num_teen_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_teen_snd <- SOPARCtoAggregate[, sum(as.numeric(num_teen_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_teen_spec <- SOPARCtoAggregate[, sum(as.numeric(num_teen_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_adult_prim <- SOPARCtoAggregate[, sum(as.numeric(num_adult_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_adult_snd <- SOPARCtoAggregate[, sum(as.numeric(num_adult_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_adult_spec <- SOPARCtoAggregate[, sum(as.numeric(num_adult_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_senior_prim <- SOPARCtoAggregate[, sum(as.numeric(num_senior_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_senior_snd <- SOPARCtoAggregate[, sum(as.numeric(num_senior_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_senior_spec <- SOPARCtoAggregate[, sum(as.numeric(num_senior_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1





```



How many people use a park
```{r}
SOPARCtoAggregate[, sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE), by = park_name]

```

Proportion of park visitors by time 
```{r}

SOPARCtoAggregate[, sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE) , by = .(park_name, period)]

SOPARCtoAggregate[, sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE) , by = .(park_name, period)][,.(V1/ sum(V1),period), by = park_name ]

```


Distribution of age group
Proportion of park attendees each age
```{r}
SOPARCtoAggregate[, .(c(sum(num_child_prim, num_child_snd, num_child_spec, na.rm = TRUE),
                      sum(num_teen_prim, num_teen_snd, num_teen_spec, na.rm = TRUE),
                      sum(num_adult_prim, num_adult_snd, num_adult_spec, na.rm = TRUE),
                      sum(num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE)), rep(c("child","teen","adult","senior"))), by = park_name]

SOPARCtoAggregate[, .(c(sum(num_child_prim, num_child_snd, num_child_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE),
                      sum(num_teen_prim, num_teen_snd, num_teen_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE),
                      sum(num_adult_prim, num_adult_snd, num_adult_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE),
                      sum(num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE)),rep(c("child","teen","adult","senior"))), by = park_name]
```


Park Occupancy:
percentage of the 24 observation periods where the park had any occupancy
Doing this by target areas has problem because the content of target areas is not stable.
```{r analysis of occupancy}

SOPARCtoAggregate[, ifelse(any(occupied %in% "Yes"), 1, 0), by = .(park_name, periodBasedOnSequence,dayNumberBasedOnSequence)][, round((sum(V1)/24 )*100,0),by=park_name]

```




Number of people doing an activity in a park
```{r}
rbind(SOPARCtoAggregate[,sum(num_child_prim, num_teen_prim, num_adult_prim, num_senior_prim, na.rm = T) , by = .(park_name,activity = prim_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_snd, num_teen_snd, num_adult_snd, num_senior_snd, na.rm = T) , by = .(park_name,activity = snd_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_spec, num_teen_spec, num_adult_spec, num_senior_spec, na.rm = T) , by = .(park_name,activity = spec_act_name)][V1 > 0,])[,sum(V1), by = .(park_name,activity)]
```


Frequency of Activities:
Counts of how often at least 1 person was doing which of the activities. Time as proportion of the 24 observation periods
```{r}
rbind(SOPARCtoAggregate[,sum(num_child_prim, num_teen_prim, num_adult_prim, num_senior_prim, na.rm = T) , by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity = prim_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_snd, num_teen_snd, num_adult_snd, num_senior_snd, na.rm = T) , by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity = prim_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_spec, num_teen_spec, num_adult_spec, num_senior_spec, na.rm = T) , by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity = prim_act_name)][V1 > 0,])[,sum(V1), by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity)][,.N / 24, by = .(park_name, activity)]
```


