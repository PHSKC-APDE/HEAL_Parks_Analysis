---
title: "HEAL Parks 2023 Analysis"
author: "Ronald Buie"
date-modified: "`r Sys.Date()`"

format: 
  pdf:
    toc: true
    number-sections: true
---

# Front Matter

## ITHS REDCap

Data are currently stored in ITHS REDCap. This is currently managed by the program managers and Ronald. This script will pull from the project if correct information is provided (see **secrets and tokens** in the **Setting Environment** section below.)

## This is a Quarto Document

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.


# 1 Setting Up Environment

```{r define constant}
USEGOODDATA <- TRUE
```

```{r load required packages}
# we prefer to use pacman to manage cran packages. 
# First check if pacman is installed. If not, install it.
if(!"pacman" %in% installed.packages()) {
  install.packages("pacman")
}

# load and install packages using pacman. 
# Pacman will install and load missing packages.
pacman::p_load("here") #used to simplify calls to local directory

```

## Secrets and tokens

In order to pull data directly from REDCap, API information must be provided. You should create a file called "secrets.txt" in this directory. This file should contain the following information:

Note, that the .gitignore for this project is configured to exclude your secrets.txt file, so, by default, it will not upload to github, and you will not be able to see other users' secrets.txt. They are only stored on your machine.


# 2 Load Data

```{r import data}
library(RCurl)
library(jsonlite)
library(here)
library(data.table)
if (file.exists(here("2023/secrets.txt"))) {
  source(here("2023/secrets.txt"))
} else {
  warning("secrets not found. checking for data.csv")
  if(!file.exists(here("2023/data.csv"))){
    stop("data not found")
  }
}


#!/usr/bin/env Rscript
token <- "FBB8FA4EA7136C81F88BEA9D15254338"
url <- "https://redcap.iths.org/api/"

formData <- list("token"=token,
    content='record',
    action='export',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)
response <- httr::POST(url, body = formData, encode = "form")
result <- httr::content(response)
#print(result)
```

```{r}
result <- postForm(
    api_url,
    token=api_token,
    content='record',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)

AllSOPARCObservations <- as.data.table(fromJSON(result), )

```

```{r preliminary cleaning and data typing}

SOPARCObservations <- copy(AllSOPARCObservations)

#remove pre-study observation (test data)
SOPARCObservations <- SOPARCObservations[record_id >= 141,]


#drop observations without a time, we cannot use these
SOPARCObservations <- SOPARCObservations[start_time != "",]
#drop observations with missing park names, we cannot use these
SOPARCObservations <- SOPARCObservations[!(park_name %in% ""),]

#convert time to time data type and save as seperate variable
SOPARCObservations[, timestampPOSIX := as.POSIXct(strptime(start_time, "%Y-%m-%d %H:%M"), "America/Los_Angeles") ]

#add day of the week
SOPARCObservations[, day := weekdays(timestampPOSIX)]
#add weekend indicator
SOPARCObservations[, weekend := ifelse(day %in% c("Saturday", "Sunday"), 1, 0)]

#convert countables to numeric
SOPARCObservations$num_child_prim <- as.numeric(SOPARCObservations$num_child_prim)
SOPARCObservations$num_child_snd <- as.numeric(SOPARCObservations$num_child_snd)
SOPARCObservations$num_child_spec <- as.numeric(SOPARCObservations$num_child_spec)
SOPARCObservations$num_teen_prim <- as.numeric(SOPARCObservations$num_teen_prim)
SOPARCObservations$num_teen_snd <- as.numeric(SOPARCObservations$num_teen_snd)
SOPARCObservations$num_teen_spec <- as.numeric(SOPARCObservations$num_teen_spec)
SOPARCObservations$num_adult_prim <- as.numeric(SOPARCObservations$num_adult_prim)
SOPARCObservations$num_adult_snd <- as.numeric(SOPARCObservations$num_adult_snd)
SOPARCObservations$num_adult_spec <- as.numeric(SOPARCObservations$num_adult_spec)
SOPARCObservations$num_senior_prim <- as.numeric(SOPARCObservations$num_senior_prim)
SOPARCObservations$num_senior_snd <- as.numeric(SOPARCObservations$num_senior_snd)
SOPARCObservations$num_senior_spec <- as.numeric(SOPARCObservations$num_senior_spec)


#SOPARCObservations$tar_area <- as.numeric(SOPARCObservations$tar_area)
#


```

```{r temp create park and area reference table with quality checks}
referenceDT <- SOPARCObservations[, .(areaCount = max(as.numeric(tar_area))), by = park_name]
observationsPerPark <- SOPARCObservations[, .(observationCount = .N), by = park_name]
parkStats <- merge(referenceDT, observationsPerPark)
parkStats[, expectedObservationCount := areaCount*24]
parkStats[, meetsExpected := ifelse(expectedObservationCount == observationCount, "PASS", "FAIL")]


```

```{r select analysis set to use}
if(USEGOODDATA) {
  SOPARCAnalysisSet <- copy(SOPARCObservations[park_name %in% parkStats[meetsExpected == "PASS"]$park_name]) #only use parks that have expected number of observation
} else {
  SOPARCAnalysisSet <- copy(SOPARCObservations) #use all parks
}
```



# Parameterizing data

Parks are observed multiple times. 8 times per day. These are in a morning, lunch, afternoon, and evening period (two data collections per period). This process is repeated for 3 days (24 sets of observations per park).

Each park is divided into one or more areas. All areas should be observed during a single observation period. Some areas may be further divided into sub areas. In our data, each area is simply assigned a number.

```{r period assignment based on sequence}


  


expectedTimeBreakpoints <- c(0800, #start morning2
                             0830, #between M2 and L1
                             1230, #start L1
                             1300, #start L2
                             1330, # between L2 and A1
                             1530, #start A1
                             1600, #start A2
                             1630, #between A2 and E1
                             1830, #start E1
                             1900) #start E2


breakPointLabels <- c("morning1",
             "morning2",
             "betweenML",
             "lunch1",
             "lunch2",
             "betweenLA",
             "afternoon1",
             "afternoon2",
             "betweeenAE",
             "evening1",
             "evening2")


 
#for remaining observations, create a list of their times, standardized to POSIX
dataCollectionTimes <- as.POSIXct(strptime(SOPARCAnalysisSet$start_time, "%Y-%m-%d %H:%M"), "America/Los_Angeles") 

breakpointAssignments <- breakPointLabels[findInterval(format(dataCollectionTimes, format = "%H%M"), expectedTimeBreakpoints, left.open = T, all.inside = FALSE, rightmost.closed = FALSE)+1]

#assign observed times to scheduled periods. Use only the house (otherwise would attribute date.)
SOPARCAnalysisSet$periodBasedOnBreakpoint <- breakpointAssignments

```

At this point rudementary timestamps have been assigned based on the expected times of observation.
Now we apply a series of heuristics to correct obvious errors.


```{r adjust timestamp assigments}

```


A second approach to assigning time periods relies on the assumption that timestamps are in order (e.g. the first observation of park A area 1 is always "morning1", the second, "morning2" and so on.)

In turn, with this approach, we assign the sequence of the day such that the first morning1 is day 1, the second is day2, and so on. 

For both of the above approaches, we assume that there are the correct number of observation periods such that 1 can be assigned to each period, and 8 to each day.
```{r assign time periods based on sequence}

sequenceLabels <- c("morning1",
             "morning2",
             "lunch1",
             "lunch2",
             "afternoon1",
             "afternoon2",
             "evening1",
             "evening2")


#apply observation period labels based on the order that a park's target area was observed
SOPARCAnalysisSet[order(park_scan_data_collection_timestamp, tar_area), periodBasedOnSequence := rep_len(sequenceLabels, .N), by = "park_name"]


#apply day sequence labels based on the order of a park's observation period
SOPARCAnalysisSet[order(park_scan_data_collection_timestamp, tar_area, periodBasedOnSequence), dayNumberBasedOnSequence := rep_len(1:3, .N), by = "park_name",]


```





save these data to review timestamp assignments
```{r}
#save for manual inspection
write.csv(SOPARCAnalysisSet, "inspectTimestamps.csv")

```


For each park, there should be 3 days of observation. We will detect this by extracting the date per park and putting observations in order of day "1" "2" "3"
```{r  assign observation day}

# #library(lubridate)
#   for(park in unique(SOPARCObservations$park_name)) {
#     daysOfYear <- yday(SOPARCObservations[park_name %in% park, start_time])
#     dayOfYear <- unique(daysOfYear)
#     if(length(dayOfYear) > 3) { warning("more than three days detected for:", park ,"\n") }
#     if(length(dayOfYear) < 3) { warning("less than three days detected for:", park ,"\n") }
#     for(dayCounter  in 1:length(dayOfYear)) {
#       SOPARCObservations[park_name %in% park & yday(start_time) == dayOfYear[dayCounter], analysisDay := dayCounter]
#     }
#   }
```


```{r prep for analysis QA}

PreQADT <- copy(SOPARCAnalysisSet)

#check if all expected time periods exists and are assigned
for(park in unique(PreQADT$park_name)) {
  multiple <- referenceDT[park_name %in% park,]$areaCount
  #check sequence based times
  for(period in sequenceLabels) {
    if(nrow(PreQADT[park_name %in% park & periodBasedOnSequence %in% period, ]) != multiple*3) { 
      PreQADT[park_name %in% park & periodBasedOnSequence %in% period, PeriodBasedOnSequencePass := 0]
    } else {
      PreQADT[park_name %in% park & periodBasedOnSequence %in% period, PeriodBasedOnSequencePass := 1]
    }
    
  }
  for(daycount in 1:3){
    #we will perform 2 check here
    #1 review if the correct number of observations are assigned to each day
    if(nrow(PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, ]) != multiple*8) { 
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayCountBasedOnSequencePass := 0]
    } else {
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayCountBasedOnSequencePass := 1]
    }
    #2 confirm that the observations assigned to the same day are flagged with the same day of the week
    if(length(unique(PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, day])) != 1) { 
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayAssignmentBasedOnSequencePass := 0]
    } else {
      PreQADT[park_name %in% park & dayNumberBasedOnSequence %in% daycount, DayAssignmentBasedOnSequencePass := 1]
    }
  }
  
}

# 
# #check if any time periods are in between assigned periods
# liminalTimes <- c("betweenML",
#                   "betweenLA",
#                   "betweeenAE")
# if(nrow(PreQADT[periodBasedOnBreakpoint %in% liminalTimes,]) >0){
#   propMissing <- round(nrow(PreQADT[periodBasedOnBreakpoint %in% liminalTimes,])/nrow(PreQADT) ,2)*100
#   warning(paste0("%", propMissing, " of observations are in liminal periods and need to be corrected for proper analysis,"))
#   warning("trimming data to only include observations with properly assigned observation periods. Do not use these results in final analysis.")
#   PreQADT[, passQABP := ifelse(!(periodBasedOnBreakpoint %in% liminalTimes)]
# } else {
#   message("OK status: All observations have been assigned to a time period")
# }
# 
# #check if parks have all expected observations
# pass <- 1
# for(park in unique(PreQADT$park_name)) {
# 
# }

QAVarList <- c("PeriodBasedOnSequencePass",
               "DayCountBasedOnSequencePass",
               "DayAssignmentBasedOnSequencePass")

QAVarList <- quote(list(PeriodBasedOnSequencePass,
               DayCountBasedOnSequencePass,
               DayAssignmentBasedOnSequencePass))

PostQADT <- copy(PreQADT)
```


save these data to review QA output
```{r}
#save for manual inspection
write.csv(PostQADT, "inspectQA.csv")

```


```{r analysis functions}


```


For all analyses, we do not want to distinguish between the first and second of a period (e.g. morning1 and morning2). This chunk attempts to aggregate these according to the following:


positive indicaters | aggregate to
--------------------|----------------------
accessible          | Yes
usable              | Yes
lit                 | Yes
occupied            | Yes
supervised          | Yes
organized           | Yes
equipped            | Yes

counts of           | are aggregated as
--------------------|-----------------------
num_child_prim      | sum
num_child_snd       | sum
num_child_spec      | sum
num_teen_prim       | sum
num_teen_snd        | sum
num_teen_spec       | sum
num_adult_prim      | sum
num_adult_snd       | sum
num_adult_spec      | sum
num_senior_prim     | sum
num_senior_snd      | sum
num_senior_spec     | sum

open text field of  | aggregate to
--------------------|--------------------------
prim_act_name       | concantinate ";"
prim_act_other      | concantinate ";"
snd_act_name        | concantinate ";"
other_act_snd       | concantinate ";"
spec_act_name       |
other_act_spec      |
comments            |

```{r period aggregation}




if(USEGOODDATA) {
  #check is all QA checks are 1, if any are not one, do not include that park
  invalidParks <- unique(PostQADT[apply(PostQADT[,eval(QAVarList)], 1, mean) != 1, park_name])
  SOPARCtoAggregate <- copy(PostQADT[!(park_name %in% invalidParks),])
} else {
  SOPARCtoAggregate <- copy(PostQADT)
}

#create single periodname for aggregating first and second of each period using sequence periods
SOPARCtoAggregate[periodBasedOnSequence %in% c("morning1","morning2"), period := "morning"]
SOPARCtoAggregate[periodBasedOnSequence %in% c("lunch1","lunch2"), period := "lunch"]
SOPARCtoAggregate[periodBasedOnSequence %in% c("afternoon1","afternoon2"), period := "afternoon"]
SOPARCtoAggregate[periodBasedOnSequence %in% c("evening1","evening2"), period := "evening"]

SOPARCAggregated <- unique.data.frame(SOPARCtoAggregate[, .(park_name, tar_area, dayNumberBasedOnSequence, period)])
  
SOPARCAggregated$accessible <- SOPARCtoAggregate[, ifelse(any(accessible %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$usable <- SOPARCtoAggregate[, ifelse(any(usable %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$lit <- SOPARCtoAggregate[, ifelse(any(lit %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$occupied <- SOPARCtoAggregate[, ifelse(any(occupied %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$supervised <- SOPARCtoAggregate[, ifelse(any(supervised %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$organized <- SOPARCtoAggregate[, ifelse(any(organized %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$equipped <- SOPARCtoAggregate[, ifelse(any(equipped %in% "Yes"), "Yes", "No"),by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1


SOPARCAggregated$num_child_prim <- SOPARCtoAggregate[, sum(as.numeric(num_child_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_child_snd <- SOPARCtoAggregate[, sum(as.numeric(num_child_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_child_spec <- SOPARCtoAggregate[, sum(as.numeric(num_child_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_teen_prim <- SOPARCtoAggregate[, sum(as.numeric(num_teen_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_teen_snd <- SOPARCtoAggregate[, sum(as.numeric(num_teen_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_teen_spec <- SOPARCtoAggregate[, sum(as.numeric(num_teen_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_adult_prim <- SOPARCtoAggregate[, sum(as.numeric(num_adult_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_adult_snd <- SOPARCtoAggregate[, sum(as.numeric(num_adult_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_adult_spec <- SOPARCtoAggregate[, sum(as.numeric(num_adult_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_senior_prim <- SOPARCtoAggregate[, sum(as.numeric(num_senior_prim)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_senior_snd <- SOPARCtoAggregate[, sum(as.numeric(num_senior_snd)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1
SOPARCAggregated$num_senior_spec <- SOPARCtoAggregate[, sum(as.numeric(num_senior_spec)), by = .(park_name, tar_area, dayNumberBasedOnSequence, period)]$V1





```



How many people use a park
```{r}
SOPARCtoAggregate[, sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE), by = park_name]

```

Proportion of park visitors by time 
```{r}

SOPARCtoAggregate[, sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE) , by = .(park_name, period)]

SOPARCtoAggregate[, sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE) , by = .(park_name, period)][,.(V1/ sum(V1),period), by = park_name ]

```


Distribution of age group
Proportion of park attendees each age
```{r}
SOPARCtoAggregate[, .(c(sum(num_child_prim, num_child_snd, num_child_spec, na.rm = TRUE),
                      sum(num_teen_prim, num_teen_snd, num_teen_spec, na.rm = TRUE),
                      sum(num_adult_prim, num_adult_snd, num_adult_spec, na.rm = TRUE),
                      sum(num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE)), rep(c("child","teen","adult","senior"))), by = park_name]

SOPARCtoAggregate[, .(c(sum(num_child_prim, num_child_snd, num_child_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE),
                      sum(num_teen_prim, num_teen_snd, num_teen_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE),
                      sum(num_adult_prim, num_adult_snd, num_adult_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE),
                      sum(num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE) / sum(num_child_prim, num_child_snd, num_child_spec, num_teen_prim, num_teen_snd, num_teen_spec, num_adult_prim, num_adult_snd, num_adult_spec, num_senior_prim, num_senior_snd, num_senior_spec, na.rm = TRUE)),rep(c("child","teen","adult","senior"))), by = park_name]
```


Park Occupancy:
percentage of the 24 observation periods where the park had any occupancy
Doing this by target areas has problem because the content of target areas is not stable.
```{r analysis of occupancy}

SOPARCtoAggregate[, ifelse(any(occupied %in% "Yes"), 1, 0), by = .(park_name, periodBasedOnSequence,dayNumberBasedOnSequence)][, round((sum(V1)/24 )*100,0),by=park_name]

```




Number of people doing an activity in a park
```{r}
rbind(SOPARCtoAggregate[,sum(num_child_prim, num_teen_prim, num_adult_prim, num_senior_prim, na.rm = T) , by = .(park_name,activity = prim_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_snd, num_teen_snd, num_adult_snd, num_senior_snd, na.rm = T) , by = .(park_name,activity = snd_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_spec, num_teen_spec, num_adult_spec, num_senior_spec, na.rm = T) , by = .(park_name,activity = spec_act_name)][V1 > 0,])[,sum(V1), by = .(park_name,activity)]
```


Frequency of Activities:
Counts of how often at least 1 person was doing which of the activities. Time as proportion of the 24 observation periods
```{r}
rbind(SOPARCtoAggregate[,sum(num_child_prim, num_teen_prim, num_adult_prim, num_senior_prim, na.rm = T) , by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity = prim_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_snd, num_teen_snd, num_adult_snd, num_senior_snd, na.rm = T) , by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity = prim_act_name)][V1 > 0,],
SOPARCtoAggregate[,sum(num_child_spec, num_teen_spec, num_adult_spec, num_senior_spec, na.rm = T) , by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity = prim_act_name)][V1 > 0,])[,sum(V1), by = .(park_name, dayNumberBasedOnSequence,periodBasedOnSequence,activity)][,.N / 24, by = .(park_name, activity)]
```


