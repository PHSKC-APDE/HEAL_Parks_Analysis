---
title: "HEAL Parks 2023 Analysis"
author: "Ronald Buie"
date-modified: "`r Sys.Date()`"

format: 
  pdf:
    toc: true
    number-sections: true
---

# Front Matter

## ITHS REDCap

Data are currently stored in ITHS REDCap. This is currently managed by the program managers and Ronald. This script will pull from the project if correct information is provided (see **secrets and tokens** in the **Setting Environment** section below.)

## This is a Quarto Document

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.


# 1 Setting Up Environment

```{r load required packages}
# we prefer to use pacman to manage cran packages. 
# First check if pacman is installed. If not, install it.
if(!"pacman" %in% installed.packages()) {
  install.packages("pacman")
}

# load and install packages using pacman. 
# Pacman will install and load missing packages.
pacman::p_load("here") #used to simplify calls to local directory

```

## Secrets and tokens

In order to pull data directly from REDCap, API information must be provided. You should create a file called "secrets.txt" in this directory. This file should contain the following information:

Note, that the .gitignore for this project is configured to exclude your secrets.txt file, so, by default, it will not upload to github, and you will not be able to see other users' secrets.txt. They are only stored on your machine.


# 2 Load Data

```{r import data}
library(RCurl)
library(jsonlite)
library(here)
library(data.table)
if (file.exists(here("2023/secrets.txt"))) {
  source(here("2023/secrets.txt"))
} else {
  warning("secrets not found. checking for data.csv")
  if(!file.exists(here("2023/data.csv"))){
    stop("data not found")
  }
}


#!/usr/bin/env Rscript
token <- "FBB8FA4EA7136C81F88BEA9D15254338"
url <- "https://redcap.iths.org/api/"

formData <- list("token"=token,
    content='record',
    action='export',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)
response <- httr::POST(url, body = formData, encode = "form")
result <- httr::content(response)
#print(result)
```

```{r}
result <- postForm(
    api_url,
    token=api_token,
    content='record',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)

AllSOPARCObservations <- as.data.table(fromJSON(result), )

```

```{r preliminary cleaning and data typing}

SOPARCObservations <- copy(AllSOPARCObservations)

#remove pre-study observation (test data)
SOPARCObservations <- SOPARCObservations[record_id >= 141,]


#drop observations without a time, we cannot use these
SOPARCObservations <- SOPARCObservations[start_time != "",]


#convert countables to numeric

```



# Parameterizing data

Parks are observed multiple times. 8 times per day. These are in a morning, lunch, afternoon, and evening period (two data collections per period). This process is repeated for 3 days (24 sets of observations per park).

Each park is divided into one or more areas. All areas should be observed during a single observation period. Some areas may be further divided into sub areas. In our data, each area is simply assigned a number.

```{r period assignment based on sequence}
expectedTimeBreakpoints <- c("08:00", #start morning2
                             "08:30", #between M2 and L1
                             "12:30", #start L1
                             "13:00", #start L2
                             "13:30", # between L2 and A1
                             "15:30", #start A1
                             "16:00", #start A2
                             "16:30", #between A2 and E1
                             "18:30", #start E1
                             "19:00") #start E2

expectedTimeBreakpoints <- c(0800, #start morning2
                             0830, #between M2 and L1
                             1230, #start L1
                             1300, #start L2
                             1330, # between L2 and A1
                             1530, #start A1
                             1600, #start A2
                             1630, #between A2 and E1
                             1830, #start E1
                             1900) #start E2


#format table to POSIX for use in analysis
breakpointsRaw <- as.POSIXct(strptime(expectedTimeBreakpoints, "%H:%M"),"America/Los_Angeles" )

breakPointLabels <- c("morning1",
             "morning2",
             "betweenML",
             "lunch1",
             "lunch2",
             "betweenLA",
             "afternoon1",
             "afternoon2",
             "betweeenAE",
             "evening1",
             "evening2")


 
#for remaining observations, create a list of their times, standardized to POSIX
dataCollectionTimes <- as.POSIXct(strptime(SOPARCObservations$start_time, "%Y-%m-%d %H:%M"), "America/Los_Angeles") 

breakpointAssignments <- breakPointLabels[findInterval(format(dataCollectionTimes, format = "%H%M"), expectedTimeBreakpoints, left.open = T, all.inside = FALSE, rightmost.closed = FALSE)+1]

#assign observed times to scheduled periods. Use only the house (otherwise would attribute date.)
SOPARCObservations$periodBasedOnBreakpoint <- breakpointAssignments

#save for manual inspection
write.csv(SOPARCObservations, "inspectTimestamps.csv")

```


For each park, there should be 3 days of observation. We will detect this by extracting the date per park and putting observations in order of day "1" "2" "3"
```{r  assign observation day}
  for(park in unique(SOPARCObservations))
```


```{r prep for analysis QA}

PreQADT <- copy(SOPARCObservations)


#check if any time periods are in between assigned periods
liminalTimes <- c("betweenML",
                  "betweenLA",
                  "betweeenAE")
if(nrow(PreQADT[periodBasedOnBreakpoint %in% liminalTimes,]) >0){
  propMissing <- round(nrow(PreQADT[periodBasedOnBreakpoint %in% liminalTimes,])/nrow(PreQADT) ,2)*100
  warning(paste0("%", propMissing, " of observations are in liminal periods and need to be corrected for proper analysis,"))
  warning("trimming data to only include observations with properly assigned observation periods. Do not use these results in final analysis.")
  PreQADT <- PreQADT[!(periodBasedOnBreakpoint %in% liminalTimes)]
} else {
  message("OK status: All observations have been assigned to a time period")
}

#check if parks have all expected observations
pass <- 1
for(park in unique(PreQADT$park_name)) {
  expectedAreas <- max(as.numeric(PreQADT[park_name %in% park, tar_area]))
  #for(periods)...
}


```


