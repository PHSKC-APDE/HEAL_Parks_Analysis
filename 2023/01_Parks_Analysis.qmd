---
title: "HEAL Parks 2023 Analysis"
author: "Ronald Buie"
date-modified: "`r Sys.Date()`"

format: 
  pdf:
    toc: true
    number-sections: true
---

# Front Matter

## ITHS REDCap

Data are currently stored in ITHS REDCap. This is currently managed by the program managers and Ronald. This script will pull from the project if correct information is provided (see **secrets and tokens** in the **Setting Environment** section below.)

## This is a Quarto Document

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.


# 1 Setting Up Environment

```{r load required packages}
# we prefer to use pacman to manage cran packages. 
# First check if pacman is installed. If not, install it.
if(!"pacman" %in% installed.packages()) {
  install.packages("pacman")
}

# load and install packages using pacman. 
# Pacman will install and load missing packages.
pacman::p_load("here") #used to simplify calls to local directory

```

## Secrets and tokens

In order to pull data directly from REDCap, API information must be provided. You should create a file called "secrets.txt" in this directory. This file should contain the following information:

Note, that the .gitignore for this project is configured to exclude your secrets.txt file, so, by default, it will not upload to github, and you will not be able to see other users' secrets.txt. They are only stored on your machine.


# 2 Load Data

```{r import data}
library(RCurl)
library(jsonlite)
library(here)
library(data.table)
if (file.exists(here("2023/secrets.txt"))) {
  source(here("2023/secrets.txt"))
} else {
  warning("secrets not found. checking for data.csv")
  if(!file.exists(here("2023/data.csv"))){
    stop("data not found")
  }
}


#!/usr/bin/env Rscript
token <- "FBB8FA4EA7136C81F88BEA9D15254338"
url <- "https://redcap.iths.org/api/"

formData <- list("token"=token,
    content='record',
    action='export',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)
response <- httr::POST(url, body = formData, encode = "form")
result <- httr::content(response)
print(result)
```

```{r}
result <- postForm(
    api_url,
    token=api_token,
    content='record',
    format='json',
    type='flat',
    csvDelimiter='',
    rawOrLabel='label',
    rawOrLabelHeaders='label',
    exportCheckboxLabel='true',
    exportSurveyFields='true',
    exportDataAccessGroups='false',
    returnFormat='json',
    dateRangeBegin='2023-07-01 01:01:01'
)

AllSOPARCObservations <- as.data.table(fromJSON(result))

SOPARCObservations <- AllSOPARCObservations[record_id >= 141,]

```


# Parameterizing data

Parks are observed multiple times. 8 times per day. These are in a morning, lunch, afternoon, and evening period (two data collections per period). This process is repeated for 3 days (24 sets of observations per park).

Each park is divided into one or more areas. All areas should be observed during a single observation period. Some areas may be further divided into sub areas. In our data, each area is simply assigned a number.

```{r, period assignment based on timestamp}
#For each park, identify and average the observations for each time period within the same day. 
#

expectedTimes <- c("07:30", "07:59", #morning1
                   "08:00", "08:29", #morning2
                   "12:30", "12:59", #lunch1
                   "13:00", "13:30", #lunch2
                   "15:30", "15:59", #afternoon1
                   "16:00", "16:29", #afternoon2
                   "18:30", "18:59", #evening1
                   "19:00", "19:29") #evening2

periods <- c("morning1",
             "morning2",
             "lunch1",
             "lunch2",
             "afternoon1",
             "afternoon2",
             "evening1",
             "evening2")

timesRaw <- as.POSIXct(strptime(expectedTimes, "%H:%M"),"America/Los_Angeles" )
#times <- as.POSIXct(AllSOPARCObservations$start_time

SOPARCObservationWTime <- SOPARCObservations[start_time != "",]
 
dataCollectionTimes <- as.POSIXct(strptime(SOPARCObservationWTime$start_time, "%Y-%m-%d %H:%M"), "America/Los_Angeles") 

#For each park, use the max area number for that park, and confirm th 

test <- periods[findInterval(format(dataCollectionTimes, format = "%H%M"), format(timesRaw, format = "%H%M"))]
SOPARCObservationWTime$periodBasedOnTimestamp <- periods[findInterval(format(dataCollectionTimes, format = "%H%M"), format(timesRaw, format = "%H%M"))]
```



For each park, there are multible areas . Some Target Areas may have Sub Areas. 

